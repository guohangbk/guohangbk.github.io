# 偏底层面试题



## 枚举

### 为什么枚举实现单例模式是安全的？
虽然普通类可以通过私有化构造器进行单例实现，但是依旧可以通过反射获取到实例。而创建的枚举类底层默认继承Enum类，在通过newInstance反射创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。
枚举类能防止使用序列化与反序列化获取新的枚举对象（任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例）



### 我通过反射能创建一个枚举实例吗？

不能，在通过反射创建的时候，Java底层会自己进行判断是否是枚举类，如果是枚举，抛参数错误异常。错误如下：Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects



### 枚举的装载过程？为什么只加载一次？
反编译一个枚举类后，就会发现定义的枚举常量都会被Java编译成一个实例对象，并且是在静态域中初始化的，而静态域是在类加载阶段的cinit中进行的初始化，所以枚举对象是线程安全的，由JVM来保证，这样就能确保枚举对象不会因为并发同时请求而错误的创建多个实例。

![反编译枚举类代码](https://gitee.com/guohangbk/resources/raw/master/images/blog/enum exception.png)



### 枚举有哪些特性
1. 特殊类型的常量值列表
2. 类型是枚举
3. 声明在类外和类内，不能为方法中
4. 声明在类外部的，不能为static ，final，abstract，protected，private
5. 可以有构造方法，普通方法，变量跟常量代码块
6. 可以给构造方法传参
7. 构造方法可以有参可以重载
8. 构造方法不能直接引用，必须总是在初始化时被调用
9. ；在声明的结尾是可选的





## 多线程
### 为什么要使用线程池
Java多线程操作可以提升系统的运行速度和效率，但是每个线程在使用的时候需要创建，在不用的时候就需要销毁，花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。
除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。在一个 JVM 里创建太多的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”。为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目。
线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。



### 使用线程池有什么坏处吗？

任何多线程应用程序都有死锁风险。虽然任何多线程程序中都有死锁的风险。当线程池被用来实现涉及许多交互对象的模拟，被模拟的对象可以相互发送查询，这些查询接下来作为排队的任务执行，查询对象又同步等待着响应时，会发生这种情况。

如果线程池太大，那么被那些线程消耗的资源可能严重地影响系统性能。

线程池和其它排队机制依靠使用 wait() 和 notify() 方法，这两个方法都难于使用。如果编码不正确，那么可能丢失通知，导致线程保持空闲状态，尽管队列中有工作要处理。

各种类型的线程池中一个严重的风险是线程泄漏，当从池中出去一个线程以执行一项任务，而在任务完成后该线程却没有返回池时，会发生这种情况。



### 线程池的提交方式
线程池的提交方式有execute方法和submit方法两种，其实submit底层也是execute。execute是没有返回值的，submit是有返回值的。
submit方式有三个重载方法，具体可以分为两个类型：Runnable和Callable。Callable是有返回值的，Runnable是无返回的。



### Runnable和Callable的区别
- Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
- Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛。
  注：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。



### 线程池的submit和execute的区别
- 可以接受的任务类型：execute只能接受Runnable类型的任务，submit不管是Runnable还是Callable类型的任务都可以接受，但是Runnable返回值均为void，所以使用Future的get()获得的还是null
- 返回值：execute的参数类型是Runable，没有返回值。submit有返回值，都是Future类型，所以需要返回值的时候必须使用submit
- 异常：execute方法执行时，会抛出(打印)堆栈异常。submit方法执行时，返回结果封装在future中，如果调用future.get()方法则必须进行异常捕获，从而可以抛出(打印)堆栈异常。



### 一个线程池中的线程异常了，那么线程池会怎么处理这个线程?
execute方法执行时，会抛出(打印)堆栈异常，因为在runWorker方法中抛出的异常，经过uncaughtException进行了异常处理打印。submit方法执行时，返回结果封装在future中，如果调用future.get()方法则必须进行异常捕获，从而可以抛出(打印)堆栈异常，如果没有调用get方法，则不展示异常信息。
线程池中一个线程出现异常，会将这个线程从线程池中移除（processWorkerExit方法），并创建新的线程（addWorker方法），同时不影响其他线程任务执行。



### Executor 框架的类结构

![Executor 框架的类结构图](https://gitee.com/guohangbk/resources/raw/master/images/blog/Executor 框架的类结构图.png)





### 了解JDK Executors线程池吗?

Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。
虽说Executors提供了多种实现，可以直接拿来使用，但是在阿里巴巴代码规约中规定线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

**默认实现：**

- newFixedThreadPool() : 创建固定大小的线程池
- newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。
- newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程
- newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。

> newFixedThreadPool和newSingleThreadExecutor：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。
> newCachedThreadPool和newScheduledThreadPool：主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。

![线程池总体API架构](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110132134325.png)



### ThreadPoolExecutor线程池

在Executors中提供了多种方便的创建线程池的方法，其中多数方法都是创建了ThreadPoolExecutor 对象来实现的创建线程池。这个ThreadPoolExecutor 对象有七个属性，对象的构造方法如下：

```java
/**
 * 使用给定的参数创建ThreadPoolExecutor.
 *
 * @param corePoolSize    核心线程池中的最大线程数
 * @param maximumPoolSize 总线程池中的最大线程数
 * @param keepAliveTime   当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
 * @param unit            keepAliveTime的单位
 * @param workQueue       任务队列, 保存已经提交但尚未被执行的线程
 * @param threadFactory   线程工厂(用于指定如果创建一个线程)
 * @param handler         拒绝策略 (当任务太多导致工作队列满时的处理策略)
 */
public ThreadPoolExecutor(int corePoolSize,//核心池线程容量
                              int maximumPoolSize,//最大线程容量
                              long keepAliveTime,//
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
	//...
}
```

**线程数量要点**：

- 如果运行线程的数量**少于**核心线程数量，则**创建新**的线程处理请求
- 如果运行线程的数量**大于**核心线程数量，**小于**最大线程数量，则当**队列满的时候才创建新**的线程
- 如果核心线程数量**等于**最大线程数量，那么将**创建固定大小**的连接池
- 如果设置了最大线程数量为**无穷**，那么允许线程池适合**任意**的并发数量

**线程空闲时间要点：**

- 当前线程数**大于**核心线程数，如果空闲时间已经超过了，那该线程会**销毁**

**排队策略要点**：

- 同步移交：**不会放到队列中，而是等待线程执行它**。如果当前线程没有执行，很可能会**新开**一个线程执行
- 无界限策略：**如果核心线程都在工作，该线程会放到队列中**。所以线程数不会超过核心线程数
- 有界限策略：**可以避免资源耗尽**，但是一定程度上减低了吞吐量

当线程关闭或者线程数量满了和队列饱和了，就有拒绝任务的情况了：

**拒绝任务策略：**

- 直接抛出异常
- 使用调用者的线程来处理
- 直接丢掉这个任务
- 丢掉最老的任务

![image-20211013215906324](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110132159362.png)




### Executor和ExecutorService的区别
- ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口
- Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。
- Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。
  除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。



### 线程池关闭

ThreadPoolExecutor提供了`shutdown()`和`shutdownNow()`两个方法来关闭线程池。

- 调用shutdown()后，线程池状态立刻**变为SHUTDOWN**，此时会执行完正在执行的任务和队列中等待的任务后才会关闭。而调用shutdownNow()，线程池状态**立刻变为STOP**。
- shutdown()**等待任务执行完**才中断线程，而shutdownNow()**不等任务执行完**就中断了线程。
- shutdown()没有返回值，而shutdownNow()会返回关闭前任务队列中未执行的任务集合



### 介绍一下你们自定义线程池的几个常用参数？怎么得来的？

![image-20211013223424255](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110132234366.png)

设置的是4个核心线程数，最大线程数也是4，等待队列使用的LinkedBlockingQueue无界限策略，如果等待队列满了，则会一直等待。这个时候，因为最大线程数和核心线程数设置的一样，就会让线程池处理当前任务，队列中的也排队等着，还有很多连队都没排上的就也得等着。

大部分都是经验估算出来的数值。

我们的系统是CPU密集型的，系统的任务对CPU处理要求比较高，尤其是定时任务这一块，庞大的数据量需要处理。根据网上查阅，CPU密集型的核心线程数建议设置为机器的CPU核数+1。我们是采用K8S部署，为了防止一个pod疯狂使用资源而拖累整个集群，所以给每个pod设置的cpu上限是4核。并且我们的定时任务不需要运算速度很快，我们就给核心线程数和最大线程数都设置为4，这样就让没有进来的任务进入队列中。队列设置为1024，队列也满的时候就等着。至于拒绝策略，因为是关乎到用户的数据，在这个地方是不能丢失数据的，所以采用了保守的策略，就是CallerRunsPolicy，用调用者的线程执行这个任务。




### 线程池队列的选择

**1. 无界队列**

队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列作为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而博主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。

当然这种队列，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。

**2. 有界队列**

当使用有限的 maximumPoolSizes 时，有界队列有助于防止资源耗尽，但是可能较难调整和控制。常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。

使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。

**3. 同步移交队列**

如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。



### 自定义线程池的工作流程？

如果运行的线程少于corePoolSize，则创建新的线程来处理请求，即使其他的辅助线程是空闲的。当运行的线程的数量大于corePoolSize并且小于maximumPoolSize的时候，新任务就会放入到等待队列workQueue中。此时的等待队列中的任务等待的时间如果超过了设定的存活时间keepAliveTime，则会销毁任务。当等待队列中的任务数量达到设定的队列最大值的时候，如果还有新任务，就会往线程池中继续创建新的线程。如果线程池中的线程数量达到了maximumPoolSize，此时还有新任务进来，就会执行设定的拒绝策略handler。

![自定义线程池的工作流程](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110131614625.png)



### 那你这个线程池满了怎么办呀？咋拒绝？有哪些拒绝策略呢？

当线程池的缓存队列已满并且线程池的线程数量达到了最大线程数时，就会执行拒绝策略。
目前有四种策略：
- AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。
- DiscardPolicy：丢弃任务，但是不抛出异常。使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。
- DiscardOldestPolicy：丢弃队列最前面（最老）的任务，然后重新提交被拒绝的任务。此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。
- CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务。如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务。



### ForkJoinPool线程池

JDK1.7中新增的一个线程池，与ThreadPoolExecutor一样，同样继承了AbstractExecutorService。ForkJoinPool是Fork/Join框架的两大核心类之一。与其它类型的ExecutorService相比，**其主要的不同在于采用了工作窃取算法(work-stealing)**：所有池中线程会尝试找到并执行已被提交到池中的或由其他线程创建的任务。这样很少有线程会处于空闲状态，非常高效。这使得能够有效地处理以下情景：**大多数由任务产生大量子任务的情况**；从外部客户端大量提交小任务到池中的情况。

![image-20211013215542155](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110132155324.png)



### 线程和进程的区别

> 进程是资源分配的最小单位，线程是CPU调度的最小单位

简单比喻：进程就像是一列火车，线程就是火车中的一节车厢。

在windows系统的任务管理器中，就有进程这一项，这里显示了系统当前正在运行的软件。比如我用迅雷下载东西，迅雷是一个进程，但是在迅雷里边可能会有多线程在执行下载这个操作。

1. 线程在进程下行进（单纯的车厢无法运行）
2. 一个进程可以包含多个线程（一辆火车可以有多个车厢）
3. 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
4. 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
5. 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
6. 进程间不会相互影响，一个线程挂掉可能将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
7. 进程可以拓展到多机，进程最适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
9. 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”



### Thead类的常见方法

1. String getName()　　返回该线程的名称。
2. void setName(String name)　　改变线程名称，使之与参数 name 相同。
3. int getPriority() 　　返回线程的优先级。
4. void setPriority(int newPriority) 　　更改线程的优先级。
5. boolean isDaemon() 　　测试该线程是否为守护线程。
6. void setDaemon(boolean on)　　将该线程标记为守护线程或用户线程。
7. **static void sleep(long millis)**	使当前线程从Running状态放弃处理器进入Block状态,休眠times毫秒，再返回Runnable状态。
8. **void interrupt()**　　中断线程。
9. static void yield()　　暂停当前正在执行的线程对象，并执行其他线程。
10. void join()　　等待该线程终止。
11. void run()
12. void start()  
13. 从Object类继承来的方法　　void notify()     void wait()





### 你是怎么理解“线程安全”的？

在并发执行的环境中，对于共享数据通过同步机制保证各个线程都可以正确的执行，不会出现数据污染的情况。或者对于某个资源，在被多个线程访问时，不管运行时执行这些线程有什么样的顺序或者交错，不会出现错误的行为，就认为这个资源是线程安全的。一般来说，对于某个资源如果只有读操作，则这个资源无需同步就是线程安全的，若有多个线程进行读写操作，则需要线程同步来保证线程安全。

总结什么是线程安全的：

- 多个线程访问同一个资源
- 资源是有状态的，比如我们上述讲的字符串拼接，这个时候数据是会有变化的



### 怎么解决线程安全性问题

当多个线程共享一个全局变量，对其做写操作时，可能会受到其他线程的干扰，从而引发线程安全问题。

解决线程安全问题最直接的办法就是加锁（同步），让多个线程排队执行，使得最后的结果在可控范围之内。加锁的方式有：同步代码块synchronized、普通同步方法、静态同步方法、Lock锁。

除此之外，还有其他方法去控制要共享的变量。

ThreadLocal为每个线程提供局部变量，解决线程安全问题，底层采用 Map 来实现，将当前线程作为key，将值存储到这个 map 中。

Volatile关键字保证可见性，一旦某个线程修改了被 Volatile 修饰的变量，其他线程能立马获取到修改后的新值，在 Java 中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或者 CPU 缓存中进行的，之后才会同步到主存，而加了 Volatile 关键字后会直接读写内存。



### Synchronized和Lock锁的区别

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取到锁，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。





### 什么是AQS、ReentrantLock和ReentrantReadWriteLock锁







### 什么是死锁，怎么避免死锁





### CountDownLatch、CyclicBarrier、Semaphore是什么？





### Atomic包下的常见子类，什么是CAS，CAS会有什么问题





### ThreadLocal是什么？主要是用来干什么的？具体的源码实现原理来说一下吧





### 线程的生命周期

![image-20211014212044434](https://gitee.com/guohangbk/resources/raw/master/images/blog/202110142120402.png)



### synchronized锁类和锁对象的区别

synchronized修饰在非静态方法上和synchronized(this){} 同步代码块效果是一样的，都是锁对象。

synchronized修饰在静态方法上和 synchronized (SyncTest1.class) {} 同步代码块效果是一样的，都是锁类。

当使用了对象锁之后，除了获得当前对象的对象锁的线程，其它线程对当前对象的所有使用对象锁的语句的访问受到阻塞，但是对非使用对象锁的语句的访问不受影响。

当使用了类锁之后，除了当前线程外，其它线程对当前类的所有 类方法的访问受到阻塞，其它的静态方法（没有使用类锁的静态方法）的访问不受影响。

特别的，可以使用 synchronized(xxx) 代码块语法将一个无用的对象xxx作为一把锁，这个时候的"对象锁"是针对于xxx对象的内部而言，对于使用对象xxx作为锁的方法块来说，不管是使用的类锁还是对象锁都互不影响。

类锁和对象锁作用域不同，两者互不影响。




## Java虚拟机
