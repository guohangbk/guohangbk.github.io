# 枚举



## 为什么枚举实现单例模式是安全的？

虽然普通类可以通过私有化构造器进行单例实现，但是依旧可以通过反射获取到实例。而创建的枚举类底层默认继承Enum类，在通过newInstance反射创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。
枚举类能防止使用序列化与反序列化获取新的枚举对象（任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例）



## 我通过反射能创建一个枚举实例吗？

不能，在通过反射创建的时候，Java底层会自己进行判断是否是枚举类，如果是枚举，抛参数错误异常。错误如下：Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects



##  枚举的装载过程？为什么只加载一次？

反编译一个枚举类后，就会发现定义的枚举常量都会被Java编译成一个实例对象，并且是在静态域中初始化的，而静态域是在类加载阶段的cinit中进行的初始化，所以枚举对象是线程安全的，由JVM来保证，这样就能确保枚举对象不会因为并发同时请求而错误的创建多个实例。

![反编译枚举类代码](https://gitee.com/guohangbk/resources/raw/master/images/blog/enum exception.png)



## 枚举有哪些特性

1. 特殊类型的常量值列表
2. 类型是枚举
3. 声明在类外和类内，不能为方法中
4. 声明在类外部的，不能为static ，final，abstract，protected，private
5. 可以有构造方法，普通方法，变量跟常量代码块
6. 可以给构造方法传参
7. 构造方法可以有参可以重载
8. 构造方法不能直接引用，必须总是在初始化时被调用
9. ；在声明的结尾是可选的

