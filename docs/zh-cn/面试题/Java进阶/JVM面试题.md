# JVM面试题



## 类加载器


## 运行时数据区


## 程序计数器

## 虚拟机栈

## 本地方法栈

## 堆



## 方法区

### 如何解决OOM
1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题
3. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
4. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

### 为什么Java8要将永久代换为元空间
1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。

### 字符串常量池StringTable为什么要调整位置？
JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。


说一下JVM内存模型吧，有哪些区？分别干什么的？
Java8的内存分代改进
JVM内存分哪几个区，每个区的作用是什么？
JVM内存分布/内存结构？栈和堆的区别？堆的结构？
新生代中为什么要分为Eden和survivor。
为什么两个survivor区？
Eden和survivor的比例分配

Java的内存分区
讲讲Jvm运行时数据区
什么时候对象会进入老年代？
JVM的内存结构，Eden和Survivor比例。
JVM内存为什么要分成新生代，老年代，持久代。
Jvm内存模型以及分区，需要详细到每个区放什么。
JVM的内存模型，Java8做了什么改
JVM内存分哪几个区，每个区的作用是什么？
java内存分配
jvm的永久代中会发生垃圾回收吗？ 










