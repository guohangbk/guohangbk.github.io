# JMM和JVM





## Java内存模式（JMM）



### JMM背景

计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大，这就导致CPU每次操作内存都要耗费很多等待时间。

为了解决内存成为计算机的瓶颈，在CPU和内存之间加了一层高速缓存，程序的执行过程就变为了：**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**

在多核CPU多线程的情况下，每个核都有自己的高速缓存，假如对同一个资源操作，都会拷贝一份共享内存中的数据。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同，就可能存在**缓存一致性问题**。也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理，这就是**处理器优化**。除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。



### 什么是Java内存模型？

计算机内存模型就是为了解决多线程场景下并发问题的一个重要规范。在不同的编程语言中，可能会有不同的实现。

Java程序是需要运行在Java虚拟机上的，Java内存模型就是一种符合内存模型规范的、屏蔽了各种硬件和操作系统的访问差异的机制和规范，保证了Java程序在各种平台下对内存的访问都能效果一致。

Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而 JMM 就作用于工作内存和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步。



### 并发编程，为了保证数据安全，需要满足哪三个特性？

1. 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
2. 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性即程序执行的顺序按照代码的先后顺序执行。

缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。







## 类加载器

### 什么是ClassLoader？

ClassLoader是类加载器，负责从文件系统或者网络中加载class文件到内存，**加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032200139.png)



### 类加载器有哪几种？加载对应的包有哪些？

类的加载器从上到下依次是Bootstrap ClassLoader、Ext ClassLoader、App ClassLoader、Customer ClassLoader

各个类加载对应的类加载目录如下：

- Boostrap ClassLoader /JAVA_HOME/jre/lib目录下的jar包
- Ext ClassLoader /JAV_HOME/jre/ext/lib目录下的jar包
- App ClassLoader 加载CLASSPATH下所指定的类库，获得要加载的文件的路径 System.getProperty("java.class.path")
- Customer ClassLoader 自定义类加载器需要继承ClassLoader，重写FindClass方法



### 双亲委派机制？

Java程序中的.java文件编译完会生成.class文件，而.class文件就是通过被称为类加载器的ClassLoader加载的，而ClassLoder在加载过程中会使用“双亲委派机制”来加载.class文件。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042126579.png)

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME$/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

**注意：ExtClassLoader的父加载器并不是BootStrapClassLoader！在Ext加载器没有找到parent的时候，会去调用JNI方法来使用BootStrapClassLoader。**



### 双亲委派托机制为什么安全

举个例子，ClassLoader加载的class文件来源很多，比如编译器编译生成的class、或者网络下载的字节码。而一些来源的class文件是不可靠的，比如我可以自定义一个java.lang.Integer类来覆盖jdk中默认的Integer类，例如下面这样：

```Java
package java.lang;
public class Integer {
    public Integer(int value) {
        System.exit(0);
    }
}
```

初始化这个Integer的构造器是会退出JVM，破坏应用程序的正常进行。如果使用双亲委派机制的话该Integer类永远不会被调用，因为委托BootStrapClassLoader加载器后，会加载JDK中的Integer类，而不会加载自定义的这个。



### 类的生命过程是什么样的？

加载--->连接(验证，准备，解析)-->初始化-->使用--->卸载

- 加载阶段

  通过类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。

- 链接阶段

  **验证**：目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

  **准备**：为类变量分配内存，并且设置该类变量的默认初始值，即零值。这里不包含用final修饰的static，因为final在编译的时候就分配好了默认值，在准备阶段会显示初始化。

  **解析**：将常量池里的符号引用转换为直接引用的过程，原来的符号引用仅仅是一个字符串，而引用的对象不一定被加载，直接引用指的是将引用对象的指针或者地址偏移量指向真正的对象，将字符串所指向的对象加载到内存中。

- 初始化

  为静态字段进行赋值。静态字段被标记为final，且字段类型是基本类型或String时，静态字段会在编译过程中完成赋值。其他情况被标记的静态字段或静态代码块，会被放置到clinit函数中进行初始化，JVM通过加锁的方式保证clinit函数只被执行一次，即静态数据只被加载一次。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032228149.png)





### 类加载的过程是什么样子的？

先查询缓存，看缓存中是否存在，缓存中存在，直接返回。

缓存不存在，会查询父类加载器，使用双亲委派机制。如果父类加载器不存在，继续查找父类的父类的加载器，如果父类的父类的加载器还是找不到，再查找子类的加载器。当最后子类都无法加载这个类的时候，才会报java.lang.ClassNotFoundException



### 类加载器是线程安全的吗？

ClassLoader类加载器是线程安全的，类加载器是调用ClassLoader类的loadclass方法，loadclass方法是使用synchronize关键词修饰的，所以是线程安全的。

![image-20211104211233782](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042112671.png)





### 类加载有几种方式？

静态加载：

- 通过new关键字来创建对象的实例

动态加载：

- 通过Class.forName()来加载类，然后调用类的newInstance()方法实例化对象。

- 通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象。









## 运行时数据区

### Java内存区域分布与概述

JVM中主要分为五个区域，分别为：堆、栈、元空间、本地方法栈、程序计数器。

1. 堆：JVM中最大的一块区域，是线程共享的，存放的是对象的实例，在虚拟机启动的时候创建。因为存放了很多对象实例，那么用不到的对象就会进行垃圾回收，所以也是JVM中主要的GC区域。
2. 栈：线程私有的，生命周期和线程的生命周期一样。在方法执行时会创建一个栈帧，每一个方法从调用到执行完成的过程也就是一个栈帧在虚拟机中出栈入栈的过程。虚拟机栈在编译器存放了基本数据类型，对象引用及局部变量。
3. 元空间：线程共享的，主要会存储常量池、方法信息、类的元信息。在JDK1.8之前是方法区，1.8改为元空间，存储内容没什么大变化。主要是使用了本地内存，也就意味着只要本地内存足够，就不会出现OOM的错误，所以一般采用JVM参数控制元空间的大小。
4. 本地方法栈：线程私有的，主要用来调用Native方法，因为Java大部分情况下不能直接调用硬件，需要借助JNI。
5. 程序计数器：程序计数器是一小块内存区域，也是线程私有的。用来储存当前线程执行的字节码的行号。 Java多线程是通过线程轮流切换并分配给处理器执行的方式实现的。所以如果当前线程切换后，要想恢复到正确的位置，就需要程序计数器了。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042139525.png)



### 什么是垃圾回收？什么时候被回收？回收算法？





### 垃圾回收器有哪些？每种回收器的特色？





### CMS垃圾回收器的优点？

mvn install:install-file -DgroupId=org.apache.commons -DartifactId=commons-collections4 -Dversion=4.4 -Dpackaging=jar -Dfile=commons-collections4-4.4.jar









## 程序计数器







## 虚拟机栈







## 本地方法栈







## 堆







## 方法区

### 方法区和元空间的区别？

JDK1.7以前方法区叫永久代，使用的是虚拟机的内存空间
而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Metaspace) 来代替
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。
永久代、元空间二者并不只是名字变了，内部结构也调整了。
根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出O0M异常。



### 为什么Java8要将永久代换为元空间

1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。



### 如何解决OOM
1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题
3. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
4. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。







### 字符串常量池StringTable为什么要调整位置？

JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。



说一下JVM内存模型吧，有哪些区？分别干什么的？
Java8的内存分代改进
JVM内存分哪几个区，每个区的作用是什么？
JVM内存分布/内存结构？栈和堆的区别？堆的结构？
新生代中为什么要分为Eden和survivor。
为什么两个survivor区？
Eden和survivor的比例分配

Java的内存分区
讲讲Jvm运行时数据区
什么时候对象会进入老年代？
JVM的内存结构，Eden和Survivor比例。
JVM内存为什么要分成新生代，老年代，持久代。
Jvm内存模型以及分区，需要详细到每个区放什么。
JVM的内存模型，Java8做了什么改
JVM内存分哪几个区，每个区的作用是什么？
java内存分配
jvm的永久代中会发生垃圾回收吗？ 
### CMS垃圾收集器







































