# JMM和JVM





## Java内存模式（JMM）



### JMM背景

计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大，这就导致CPU每次操作内存都要耗费很多等待时间。

为了解决内存成为计算机的瓶颈，在CPU和内存之间加了一层高速缓存，程序的执行过程就变为了：**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**

在多核CPU多线程的情况下，每个核都有自己的高速缓存，假如对同一个资源操作，都会拷贝一份共享内存中的数据。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同，就可能存在**缓存一致性问题**。也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理，这就是**处理器优化**。除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。



### 什么是Java内存模型？

计算机内存模型就是为了解决多线程场景下并发问题的一个重要规范。在不同的编程语言中，可能会有不同的实现。

Java程序是需要运行在Java虚拟机上的，Java内存模型就是一种符合内存模型规范的、屏蔽了各种硬件和操作系统的访问差异的机制和规范，保证了Java程序在各种平台下对内存的访问都能效果一致。

Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而 JMM 就作用于工作内存和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步。



### 并发编程，为了保证数据安全，需要满足哪三个特性？

1. 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
2. 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性即程序执行的顺序按照代码的先后顺序执行。

缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。







## 类加载器

### 什么是ClassLoader？

ClassLoader是类加载器，负责从文件系统或者网络中加载class文件到内存，**加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032200139.png)



### 类加载器有哪几种？加载对应的包有哪些？

类的加载器从上到下依次是Bootstrap ClassLoader、Ext ClassLoader、App ClassLoader、Customer ClassLoader

各个类加载对应的类加载目录如下：

- Boostrap ClassLoader /JAVA_HOME/jre/lib目录下的jar包
- Ext ClassLoader /JAV_HOME/jre/ext/lib目录下的jar包
- App ClassLoader 加载CLASSPATH下所指定的类库，获得要加载的文件的路径 System.getProperty("java.class.path")
- Customer ClassLoader 自定义类加载器需要继承ClassLoader，重写FindClass方法



### 双亲委派机制？

Java程序中的.java文件编译完会生成.class文件，而.class文件就是通过被称为类加载器的ClassLoader加载的，而ClassLoder在加载过程中会使用“双亲委派机制”来加载.class文件。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042126579.png)

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME$/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

**注意：ExtClassLoader的父加载器并不是BootStrapClassLoader！在Ext加载器没有找到parent的时候，会去调用JNI方法来使用BootStrapClassLoader。**



### 双亲委派托机制为什么安全

举个例子，ClassLoader加载的class文件来源很多，比如编译器编译生成的class、或者网络下载的字节码。而一些来源的class文件是不可靠的，比如我可以自定义一个java.lang.Integer类来覆盖jdk中默认的Integer类，例如下面这样：

```Java
package java.lang;
public class Integer {
    public Integer(int value) {
        System.exit(0);
    }
}
```

初始化这个Integer的构造器是会退出JVM，破坏应用程序的正常进行。如果使用双亲委派机制的话该Integer类永远不会被调用，因为委托BootStrapClassLoader加载器后，会加载JDK中的Integer类，而不会加载自定义的这个。



### 类的生命过程是什么样的？

加载--->连接(验证，准备，解析)-->初始化-->使用--->卸载

- 加载阶段

  通过类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。

- 链接阶段

  **验证**：目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

  **准备**：为类变量分配内存，并且设置该类变量的默认初始值，即零值。这里不包含用final修饰的static，因为final在编译的时候就分配好了默认值，在准备阶段会显示初始化。

  **解析**：将常量池里的符号引用转换为直接引用的过程，原来的符号引用仅仅是一个字符串，而引用的对象不一定被加载，直接引用指的是将引用对象的指针或者地址偏移量指向真正的对象，将字符串所指向的对象加载到内存中。

- 初始化

  为静态字段进行赋值。静态字段被标记为final，且字段类型是基本类型或String时，静态字段会在编译过程中完成赋值。其他情况被标记的静态字段或静态代码块，会被放置到clinit函数中进行初始化，JVM通过加锁的方式保证clinit函数只被执行一次，即静态数据只被加载一次。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032228149.png)





### 类加载的过程是什么样子的？

先查询缓存，看缓存中是否存在，缓存中存在，直接返回。

缓存不存在，会查询父类加载器，使用双亲委派机制。如果父类加载器不存在，继续查找父类的父类的加载器，如果父类的父类的加载器还是找不到，再查找子类的加载器。当最后子类都无法加载这个类的时候，才会报java.lang.ClassNotFoundException



### 类加载器是线程安全的吗？

ClassLoader类加载器是线程安全的，类加载器是调用ClassLoader类的loadclass方法，loadclass方法是使用synchronize关键词修饰的，所以是线程安全的。

![image-20211104211233782](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042112671.png)





### 类加载有几种方式？

静态加载：

- 通过new关键字来创建对象的实例

动态加载：

- 通过Class.forName()来加载类，然后调用类的newInstance()方法实例化对象。

- 通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象。









## 运行时数据区

### Java内存区域分布与概述

JVM中主要分为五个区域，分别为：堆、栈、元空间、本地方法栈、程序计数器。

1. 堆：JVM中最大的一块区域，是线程共享的，存放的是对象的实例，在虚拟机启动的时候创建。因为存放了很多对象实例，那么用不到的对象就会进行垃圾回收，所以也是JVM中主要的GC区域。
2. 栈：线程私有的，生命周期和线程的生命周期一样。在方法执行时会创建一个栈帧，每一个方法从调用到执行完成的过程也就是一个栈帧在虚拟机中出栈入栈的过程。虚拟机栈在编译器存放了基本数据类型，对象引用及局部变量。
3. 元空间：线程共享的，主要会存储常量池、方法信息、类的元信息。在JDK1.8之前是方法区，1.8改为元空间，存储内容没什么大变化。主要是使用了本地内存，也就意味着只要本地内存足够，就不会出现OOM的错误，所以一般采用JVM参数控制元空间的大小。
4. 本地方法栈：线程私有的，主要用来调用Native方法，因为Java大部分情况下不能直接调用硬件，需要借助JNI。
5. 程序计数器：程序计数器是一小块内存区域，也是线程私有的。用来储存当前线程执行的字节码的行号。 Java多线程是通过线程轮流切换并分配给处理器执行的方式实现的。所以如果当前线程切换后，要想恢复到正确的位置，就需要程序计数器了。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042139525.png)



### 运行时数据区，哪些部分存在Error和GC？

| 运行时数据区 | 是否存在Error    | 是否存在GC |
| ------------ | ---------------- | ---------- |
| 程序计数器   | 否               | 否         |
| 虚拟机栈     | 是（SOF）        | 否         |
| 本地方法栈   | 是               | 否         |
| 方法区       | 1.8之前是（OOM） | 是         |
| 堆           | 是（OOM）        | 是         |







## 程序计数器

### 程序计数器介绍

JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，它是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域。

在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。



### 使用PC寄存器存储字节码指令地址有什么用呢？

因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。



### PC寄存器为什么被设定为私有的？

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？
为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。
由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111051626301.png)







## 虚拟机栈

### Java虚拟机栈是什么？

Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的。栈的生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。对于栈来说不存在垃圾回收问题，存在溢出的情况。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061501298.png)



### 虚拟机栈的作用？

主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：

1. 每个方法执行，伴随着**进栈**（入栈、压栈）
2. 执行结束后的**出栈**工作



### 栈中可能出现的异常

Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。
如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackoverflowError **异常。
如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个**OutofMemoryError**异常。



### 栈的运行原理

1. JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈和出栈**，遵循先进后出（后进先出）原则。
2. 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即**只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的**

- - 这个栈帧被称为**当前栈帧（Current Frame）**
  - 与当前栈帧相对应的方法就是**当前方法（Current Method）**
  - 定义这个方法的类就是**当前类（Current Class）**

3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
5. **不同线程中所包含的栈帧是不允许存在相互引用的**，即不可能在一个栈帧之中引用另外一个线程的栈帧。
6. 如果当前方法调用了其他方法，**方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧**，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
7. Java方法有两种返回函数的方式，但不管使用哪种方式，都会导致栈帧被弹出

- - 一种是**正常的函数返回**，使用return指令
  - 另外一种是**抛出异常**

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061507677.png)

### 栈的内部结构

**每个栈帧中存储着：**

1. 局部变量表（Local Variables）
2. 操作数栈（Operand Stack）（或表达式栈）
3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
4. 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
5. 一些附加信息

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061508054.png)

并行每个线程下的栈都是私有的，因此每个线程都有各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061508405.png)



### 局部变量表的介绍

局部变量表：Local Variables，被称之为局部变量数组或本地变量表。定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的。
方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
局部变量表中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。



### 操作数栈

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）。操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）。某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，比如：执行复制、交换、求和等操作。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061513909.png)

### 栈顶缓存技术

Top Of Stack Cashing

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。
寄存器的主要优点：指令更少，执行速度快



### 动态链接

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令。
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061517589.png)



### 方法中定义的局部变量是否线程安全？

如果只有一个线程才可以操作此数据，则必是线程安全的。如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。

具体问题具体分析：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。









## 本地方法栈

### 本地方法栈的特点

Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。本地方法栈，也是线程私有的。
允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。
如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。
本地方法一般是使用C语言实现的。它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061535066.png)



### 为什么要使用本地方法接口？

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

- 与Java环境的交互
  有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因。Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

- 与操作系统的交互
  JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持，这些底层系统常常是强大的操作系统。
  通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

- Sun’s Java
  Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
  例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。
  这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。







## 堆

### 对堆的认识



### 堆内存细分



### Java对象分类





### 对象分配过程



### 幸存区满了怎么办



### 堆空间分代思想



### 内存分配策略



### 什么是TLAB



### 为什么需要TLAB



### TLAB分配过程



### 为什么要进行空间担保



### 堆是分配对象的唯一选择么？



### 逃逸分析



### 栈上分配





### 标量替换









### 什么是垃圾回收？什么时候被回收？回收算法？







### 垃圾回收器有哪些？每种回收器的特色？





### CMS垃圾回收器的优点？











## 元空间（1.8之前的方法区）

### 方法区和元空间的区别？

JDK1.7以前方法区叫永久代，使用的是虚拟机的内存空间
而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Metaspace) 来代替
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。
永久代、元空间二者并不只是名字变了，内部结构也调整了。
根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出O0M异常。



### 为什么Java8要将永久代换为元空间

1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。



### 如何解决OOM
1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题
3. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
4. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。







### 字符串常量池StringTable为什么要调整位置？

JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。



说一下JVM内存模型吧，有哪些区？分别干什么的？
Java8的内存分代改进
JVM内存分哪几个区，每个区的作用是什么？
JVM内存分布/内存结构？栈和堆的区别？堆的结构？
新生代中为什么要分为Eden和survivor。
为什么两个survivor区？
Eden和survivor的比例分配

Java的内存分区
讲讲Jvm运行时数据区
什么时候对象会进入老年代？
JVM的内存结构，Eden和Survivor比例。
JVM内存为什么要分成新生代，老年代，持久代。
Jvm内存模型以及分区，需要详细到每个区放什么。
JVM的内存模型，Java8做了什么改
JVM内存分哪几个区，每个区的作用是什么？
java内存分配
jvm的永久代中会发生垃圾回收吗？ 
### CMS垃圾收集器







































