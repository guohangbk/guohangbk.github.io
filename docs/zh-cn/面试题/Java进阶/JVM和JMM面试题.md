# JMM和JVM





## Java内存模式（JMM）



### JMM背景

计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大，这就导致CPU每次操作内存都要耗费很多等待时间。

为了解决内存成为计算机的瓶颈，在CPU和内存之间加了一层高速缓存，程序的执行过程就变为了：**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**

在多核CPU多线程的情况下，每个核都有自己的高速缓存，假如对同一个资源操作，都会拷贝一份共享内存中的数据。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同，就可能存在**缓存一致性问题**。也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理，这就是**处理器优化**。除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。



### 什么是Java内存模型？

计算机内存模型就是为了解决多线程场景下并发问题的一个重要规范。在不同的编程语言中，可能会有不同的实现。

Java程序是需要运行在Java虚拟机上的，Java内存模型就是一种符合内存模型规范的、屏蔽了各种硬件和操作系统的访问差异的机制和规范，保证了Java程序在各种平台下对内存的访问都能效果一致。

Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而 JMM 就作用于工作内存和主存之间数据同步过程，它规定了如何做数据同步以及什么时候做数据同步。



### 并发编程，为了保证数据安全，需要满足哪三个特性？

1. 原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
2. 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性即程序执行的顺序按照代码的先后顺序执行。

缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。







## 类加载器

### 什么是ClassLoader？

ClassLoader是类加载器，负责从文件系统或者网络中加载class文件到内存，**加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032200139.png)



### 类加载器有哪几种？加载对应的包有哪些？

类的加载器从上到下依次是Bootstrap ClassLoader、Ext ClassLoader、App ClassLoader、Customer ClassLoader

各个类加载对应的类加载目录如下：

- Boostrap ClassLoader /JAVA_HOME/jre/lib目录下的jar包
- Ext ClassLoader /JAV_HOME/jre/ext/lib目录下的jar包
- App ClassLoader 加载CLASSPATH下所指定的类库，获得要加载的文件的路径 System.getProperty("java.class.path")
- Customer ClassLoader 自定义类加载器需要继承ClassLoader，重写FindClass方法



### 双亲委派机制？

Java程序中的.java文件编译完会生成.class文件，而.class文件就是通过被称为类加载器的ClassLoader加载的，而ClassLoder在加载过程中会使用“双亲委派机制”来加载.class文件。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042126579.png)

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME$/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

**注意：ExtClassLoader的父加载器并不是BootStrapClassLoader！在Ext加载器没有找到parent的时候，会去调用JNI方法来使用BootStrapClassLoader。**



### 双亲委派托机制为什么安全

举个例子，ClassLoader加载的class文件来源很多，比如编译器编译生成的class、或者网络下载的字节码。而一些来源的class文件是不可靠的，比如我可以自定义一个java.lang.Integer类来覆盖jdk中默认的Integer类，例如下面这样：

```Java
package java.lang;
public class Integer {
    public Integer(int value) {
        System.exit(0);
    }
}
```

初始化这个Integer的构造器是会退出JVM，破坏应用程序的正常进行。如果使用双亲委派机制的话该Integer类永远不会被调用，因为委托BootStrapClassLoader加载器后，会加载JDK中的Integer类，而不会加载自定义的这个。



### 类的生命过程是什么样的？

加载--->连接(验证，准备，解析)-->初始化-->使用--->卸载

- 加载阶段

  通过类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。

- 链接阶段

  **验证**：目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

  **准备**：为类变量分配内存，并且设置该类变量的默认初始值，即零值。这里不包含用final修饰的static，因为final在编译的时候就分配好了默认值，在准备阶段会显示初始化。

  **解析**：将常量池里的符号引用转换为直接引用的过程，原来的符号引用仅仅是一个字符串，而引用的对象不一定被加载，直接引用指的是将引用对象的指针或者地址偏移量指向真正的对象，将字符串所指向的对象加载到内存中。

- 初始化

  为静态字段进行赋值。静态字段被标记为final，且字段类型是基本类型或String时，静态字段会在编译过程中完成赋值。其他情况被标记的静态字段或静态代码块，会被放置到clinit函数中进行初始化，JVM通过加锁的方式保证clinit函数只被执行一次，即静态数据只被加载一次。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111032228149.png)





### 类加载的过程是什么样子的？

先查询缓存，看缓存中是否存在，缓存中存在，直接返回。

缓存不存在，会查询父类加载器，使用双亲委派机制。如果父类加载器不存在，继续查找父类的父类的加载器，如果父类的父类的加载器还是找不到，再查找子类的加载器。当最后子类都无法加载这个类的时候，才会报java.lang.ClassNotFoundException



### 类加载器是线程安全的吗？

ClassLoader类加载器是线程安全的，类加载器是调用ClassLoader类的loadclass方法，loadclass方法是使用synchronize关键词修饰的，所以是线程安全的。

![image-20211104211233782](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042112671.png)





### 类加载有几种方式？

静态加载：

- 通过new关键字来创建对象的实例

动态加载：

- 通过Class.forName()来加载类，然后调用类的newInstance()方法实例化对象。

- 通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象。









## 运行时数据区

### JVM内存分布，有哪些区？做什么用？

JVM中主要分为五个区域，分别为：堆、栈、元空间、本地方法栈、程序计数器。

1. 堆：JVM中最大的一块区域，是线程共享的，存放的是对象的实例，在虚拟机启动的时候创建。因为存放了很多对象实例，那么用不到的对象就会进行垃圾回收，所以也是JVM中主要的GC区域。
2. 栈：线程私有的，生命周期和线程的生命周期一样。在方法执行时会创建一个栈帧，每一个方法从调用到执行完成的过程也就是一个栈帧在虚拟机中出栈入栈的过程。虚拟机栈在编译器存放了基本数据类型，对象引用及局部变量。
3. 元空间：线程共享的，主要会存储常量池、方法信息、类的元信息。在JDK1.8之前是方法区，1.8改为元空间，存储内容没什么大变化。主要是使用了本地内存，也就意味着只要本地内存足够，就不会出现OOM的错误，所以一般采用JVM参数控制元空间的大小。
4. 本地方法栈：线程私有的，主要用来调用Native方法，因为Java大部分情况下不能直接调用硬件，需要借助JNI。
5. 程序计数器：程序计数器是一小块内存区域，也是线程私有的。用来储存当前线程执行的字节码的行号。 Java多线程是通过线程轮流切换并分配给处理器执行的方式实现的。所以如果当前线程切换后，要想恢复到正确的位置，就需要程序计数器了。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111042139525.png)



### 运行时数据区，哪些部分存在Error和GC？

| 运行时数据区 | 是否存在Error    | 是否存在GC |
| ------------ | ---------------- | ---------- |
| 程序计数器   | 否               | 否         |
| 虚拟机栈     | 是（SOF）        | 否         |
| 本地方法栈   | 是               | 否         |
| 方法区       | 1.8之前是（OOM） | 是         |
| 堆           | 是（OOM）        | 是         |







## 程序计数器

### 程序计数器介绍

JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，它是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域。

在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。



### 使用PC寄存器存储字节码指令地址有什么用呢？

因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。



### PC寄存器为什么被设定为私有的？

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？
为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。
由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111051626301.png)







## 虚拟机栈

### Java虚拟机栈是什么？

Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的。栈的生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。对于栈来说不存在垃圾回收问题，存在溢出的情况。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061501298.png)



### 虚拟机栈的作用？

主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：

1. 每个方法执行，伴随着**进栈**（入栈、压栈）
2. 执行结束后的**出栈**工作



### 栈中可能出现的异常

Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。
如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackoverflowError **异常。
如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个**OutofMemoryError**异常。



### 栈的运行原理

1. JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈和出栈**，遵循先进后出（后进先出）原则。
2. 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即**只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的**

- - 这个栈帧被称为**当前栈帧（Current Frame）**
  - 与当前栈帧相对应的方法就是**当前方法（Current Method）**
  - 定义这个方法的类就是**当前类（Current Class）**

3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
5. **不同线程中所包含的栈帧是不允许存在相互引用的**，即不可能在一个栈帧之中引用另外一个线程的栈帧。
6. 如果当前方法调用了其他方法，**方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧**，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
7. Java方法有两种返回函数的方式，但不管使用哪种方式，都会导致栈帧被弹出

- - 一种是**正常的函数返回**，使用return指令
  - 另外一种是**抛出异常**

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061507677.png)

### 栈的内部结构

**每个栈帧中存储着：**

1. 局部变量表（Local Variables）
2. 操作数栈（Operand Stack）（或表达式栈）
3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
4. 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
5. 一些附加信息

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061508054.png)

并行每个线程下的栈都是私有的，因此每个线程都有各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061508405.png)



### 局部变量表的介绍

局部变量表：Local Variables，被称之为局部变量数组或本地变量表。定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的。
方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
局部变量表中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。



### 操作数栈

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）。操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）。某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，比如：执行复制、交换、求和等操作。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061513909.png)

### 栈顶缓存技术

Top Of Stack Cashing

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。
寄存器的主要优点：指令更少，执行速度快



### 动态链接

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令。
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061517589.png)



### 方法中定义的局部变量是否线程安全？

如果只有一个线程才可以操作此数据，则必是线程安全的。如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。

具体问题具体分析：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。









## 本地方法栈

### 本地方法栈的特点

Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。本地方法栈，也是线程私有的。
允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。
如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。
本地方法一般是使用C语言实现的。它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111061535066.png)



### 为什么要使用本地方法接口？

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

- 与Java环境的交互
  有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因。Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

- 与操作系统的交互
  JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持，这些底层系统常常是强大的操作系统。
  通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

- Sun’s Java
  Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
  例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。
  这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。







## 堆

### 对堆的认识

一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。Java堆在JVM启动的时候被创建，其空间大小也就确定了，可以通过修改JVM参数来控制堆区的大小。

**堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的**。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。从实际使用角度看的，“几乎”所有的对象实例都在这里分配内存，因为还有一些对象是在栈上分配的（逃逸分析，标量替换）。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。也就是触发了GC的时候，才会进行回收。如果堆中对象马上被回收，那么用户线程就会受到影响，因为有stop the world。
![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071107182.png)





### 堆内存细分

- Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区

  Young/New Generation Space 新生区，又被划分为Eden区和Survivor区
  Old/Tenure generation space 养老区
  Permanent Space永久区 Perm

- Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间

  Young/New Generation Space 新生区，又被划分为Eden区和Survivor区
  Old/Tenure generation space 养老区
  Meta Space 元空间 Meta

- 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071108775.png)

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071108771.png)



### Java对象分类

存储在JVM中的Java对象可以被划分为两类：一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速生命周期短的，及时回收即可。另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）。其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071109345.png)



### 新老年代比例

默认为新生代占堆内存的1/3，老年代占2/3，可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5。当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整老年代的大小，来进行调优。

在新生代中Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，也可以通过选项**-XX:SurvivorRatio**调整这个空间比例，比如-XX:SurvivorRatio=8。新生区的对象默认生命周期超过 15 ，就会去养老区养老。



### 新生代中为什么要分为Eden和survivor？

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比 Minor GC长得多，所以需要分为Eden和Survivor。

Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的 预筛选保证，只有经历15次Minor GC还能在新生代中存活的对象，才会被送到老年代。 设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次 Minor GC，Eden中的存活对象就会被移动到S0，Eden被清空；等 Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入 S1。（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）



### 为什么两个survivor区？

新生代采用复制算法，更加高效，且需要对新生代进行分区。设置两个Survivor区最大的好处就是解决了碎片化。

两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到15次，该对象就会被送到老年代中。



### JVM内存为什么要分成新生代，老年代，永久代

Java对象大多数都是新对象，可能用不了几次就会被垃圾回收掉，只有很小一部分的对象会存活的比较久。根据对象存活的时间来看，有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区，不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点，提高效率，所以就有了新生代和老年代。

永久代又称“非堆内存”，是一个概念，在JDK8之前主要体现在方法区上，存放了类信息、方法等。在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。 



### 对象分配过程

new的对象先放Eden区，此区有大小限制。当Eden区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收（MinorGC），将Eden区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden区，然后将Eden中的剩余对象移动到Survivor 0区。
如果再次触发垃圾回收，此时上次幸存下来的放到Survivor 0区的，如果没有回收，就会放到Survivor 1区。
如果再次经历垃圾回收，此时会重新放回Survivor 0区，接着再去Survivor 1区。
啥时候能去养老区呢？可以设置次数，默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：-XX:MaxTenuringThreshold=N 进行设置。
在养老区，相对悠闲，当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下，那只能便宜了某些新对象，让他们直接晋升至老年区。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071117759.png)

如果 Eden 放得下，则直接放到 Eden 区。如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？放得下最好当然最好，放不下会看幸存者区是否可以放下，如果还不能放下会直接放入老年代。如果老年代也不能放下，会fullGC，FullGC后还不能放下，就OOM。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071126608.png)



### 幸存区满了怎么办

在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作。如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。



### 堆空间分代思想

不同对象的生命周期不同。70% - 99%的对象是临时对象。

新生代：有Eden、两块大小相同的Survivor（又称from/to，s0/s1）构成，to总为空。

老年代：存放新生代中经历多次GC仍然存活的对象。

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  * 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
  * 老年代收集（Major GC/Old GC）：只是老年代的圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
  * 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为

- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。



### 内存分配策略

- 对象晋升规则

  如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。
  对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置

- 不同年龄段的对象分配原则
  1. 优先分配到Eden：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢。
  2. 大对象直接分配到老年代：应该尽量避免程序中出现过多的大对象。
  3. 长期存活的对象分配到老年代。
  4. 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
  5. 空间分配担保： -XX:HandlePromotionFailure，也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。



### 什么是TLAB

TLAB 是虚拟机在内存的 eden 区划分出来的一块专用空间，是**线程私有**的。在启用 TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块 TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。所以说，因为有了 TLAB 技术，堆内存并不是完完全全的线程共享，其中 eden 区中还是有一部分空间是分配给线程独享的。

也就是说，虽然每个线程在初始化时都会去堆内存中申请一块 TLAB，并不是说这个 TLAB 区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。并且，在 TLAB 分配之后，并不影响对象的移动和回收。也就是说，虽然对象刚开始可能通过 TLAB 分配内存，存放在 Eden 区，但是还是会被垃圾回收或者被移到 S 区和老年代等。

TLAB 是在 eden 区分配的，因为 eden 区域本身就不太大，而且 TLAB 空间的内存也非常小，默认情况下仅占有整个 eden 空间的 1%。所以，必然存在一些大对象是无法在 TLAB 直接分配。遇到 TLAB 中无法分配的大对象，对象还是可能在 eden 区或者老年代等进行分配的，但是这种分配就需要进行同步控制（加锁），这也是为什么小的对象比大的对象分配起来更加高效。

注意：这里 TLAB 的线程独享是针对于分配动作，至于读取、垃圾回收等工作是线程共享的，而且在使用上也没什么区别。 

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071433622.png)



### 为什么需要TLAB

TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区
堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。



### Java对象的内存分配过程如何保证线程安全的？

因为堆是线程之间共享的，如果在并发场景中，两个线程先后把对象的引用指向了同一个内存区域，怎么办？

为了解决这个并发问题，对象的内存分配过程就必须进行同步控制，但是，无论使用哪种方案（有可能是CAS），都会影响内存的分配效率。然而对于 Java 来说对象的分配是高频操作。

由此 HotSpot 虚拟机采用了这个方案：每个线程在 Java 堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己的这块”私有“内存中进行分配，当这部分用完之后，再分配新的”私有“内存。

这种方案被称之为 TLAB 分配。这部分 buffer 是从堆中划分出来的，但是本地线程独享的。



### TLAB分配过程

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071441417.png)





### 为什么要进行空间分配担保

是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。



### 堆是分配对象的唯一选择么？

**在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：**

1. 随着JIT编译期的发展与逃逸分析技术逐渐成熟，**栈上分配、标量替换**优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
2. 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了，这也是最常见的堆外存储技术。
3. 在基于OpenJDK深度定制的TaoBao VM中，创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。



### 逃逸分析以及优点

````Java
// 没有发生逃逸
public void useEscapeAnalysis(){
    EscapeAnalysis e = new EscapeAnalysis();
}
// 为成员属性赋值，发生逃逸
public void setObj(){
    this.obj = new EscapeAnalysis();
}
````

逃逸分析结论：开发中能使用局部变量的，就不要使用在方法外定义。

使用逃逸分析，编译器可以对代码做如下优化：

1. 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配
2. 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
3. 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。



### 什么是栈上分配

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。



### 什么是同步省略

线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。



### 什么是标量替换

标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间，这个过程就是标量替换。

那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为栈上分配提供了很好的基础。







## 元空间（1.8之前的方法区）

### 方法区介绍

方法区（Method Area）与Java堆一样，是**各个线程共享的内存区域**。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类，即**类只能加载一次**。在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。

方法区的大小，跟堆空间一样，可以选择**固定大小或者可扩展**，方法区大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误。正是因为方法区大小无法精准设置，并且GC效率低，在Java8的时候，将方法区改为元空间，使用本地内存。



### 方法区和元空间的区别？

JDK1.7以前方法区叫永久代，使用的是虚拟机的内存空间，而到了JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Metaspace) 来代替。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。

不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存，只要本机内存够用就不会OOM。而方法区无法满足新的内存分配需求时，将抛出O0M异常。



### 为什么Java8要将永久代换为元空间

1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。



### 如何解决OOM
1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题
3. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
4. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



### 字符串常量池为什么要调整位置？

在JDK1.6及之前，字符串常量池存放在方法区中。到JDK1.7之后，就从方法区中移除了，而存放在堆中。

因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收。而Full GC是老年代的空间不足、永久代不足时才会触发， 这就导致字符串回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。将字符串常量池放到堆里，能及时回收内存。

在JDK1.6中，如果字符串常量池中已经存在该字符串对象，则直接返回池中此字符串对象的引用。否则，将此字符串的对象添加到字符串常量池中，然后返回该字符串对象的引用。

在JDK1.7中，如果字符串常量池中已经存在该字符串对象，则返回池中此字符串对象的引用。否则，如果堆中已经有这个字符串对象了，则把此字符串对象的引用添加到字符串常量池中并返回该引用，如果堆中没有此字符串对象，则先在堆中创建字符串对象，再返回其引用。（这也说明，此时字符串常量池中存储的是对象的引用，而对象本身存储于堆中）



### 方法区（元空间）内部存储什么？

存储class的信息、字段、方法、class常量池、运行时常量池。

常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

- 字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;
- 符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。

运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern())，符号引用可以被解析为直接引用。

JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

![img](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111072236499.png)



### 方法区的垃圾收集

Hotspot虚拟机中的元空间或者永久代是有垃圾收集这一行为的。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
一般来说方法区回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。







## 垃圾回收

### 什么是垃圾回收？什么时候被回收？

垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

当对象跟GC Root节点没有任何的引用链的时候，判断此对象是无效的，即可以被回收。



### 如何确定垃圾

- 引用计数法

  引用计数算法（Reachability Counting）是给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1；当引用失效时，计数器就-1；任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”。引用计数法实现简单，判定效率也比较高，在大部分情况下都是一个比较好的算法，Python就是采用的引用计数法来进行内存管理的。但是，在主流的JVM中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。

![image-20211107174337778](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071743895.png)

- 可达性分析算法

  可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。

  通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。

  

![image-20211107174438503](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071744584.png)



### 哪些对象可以作为GC Root

在 Java 语言中，可作为 GC Root 的对象包括以下4种：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象



### 垃圾回收算法

- 标记-清除算法

  标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先对内存区域中的对象属于可回收的标记出来，然后把这些垃圾拎出来清理掉。清理掉的垃圾的占用就变成未使用的内存区域，等待被再次使用。它存在一个很大的问题，那就是内存碎片。当有大对象需要存储的时候，就需要很长的连续存储空间，这样就导致，其实我们本身还有这么多的内存的，但却用不了。

  ![image-20211107175248988](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071752049.png)

  

- 复制算法

  复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。

  该算法在JVM的年轻代使用，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。

![image-20211107175442985](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071754966.png)



- 标记-整理算法

  标记整理算法（Mark-Compact）标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。

  标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。但它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。

  在JVM的老年代中使用了标记-整理算法，老年代中的对象一般寿命比较长，每次垃圾回收后会有大量对象存活。并且老年代存放的大对象比较多，还会做空间担保分配。所以对于老年代来说，空间是比较珍贵的，连续的空间更为珍贵。

![image-20211107175626259](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111071756286.png)



- 分代收集算法

  严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记- 整理算法来进行回收。



### 垃圾回收器有哪些？每种回收器的特色？

并行：多条垃圾回收线程同时操作。

并发：垃圾回收线程与用户线程一起操作

#### 新生代垃圾回收器

1. Serial(串行GC)收集器：是一个新生代收集器，单线程执行，使用**复制算法**。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，适用于单cpu机器的场景。在用户的桌面应用场景中，即Client模式下的虚拟机来说是一个很好的选择。

2. ParNew(并行GC)收集器：是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样，也**复制算法**。它是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。ParNew在单CPU环境下绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分百保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对GC时系统资源的有效利用还是很有好处的。
3. Parallel Scavenge(并行回收GC)收集器：一个新生代收集器，它也是使用**复制算法**的收集器，又是并行多线程收集器。Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。由于于吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器。Parallel Scavenge收集器有一个参数-XX:UseAdaptiveSizePolicy，当这个参数打开，虚拟机会根据当前系统的运行状况收集性能监控信息，动态调整一些如新生代大小、Eden与Survivor区的比例等等细节参数。这种自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。<font color="red">Java8中默认的新生代收集器。</font>

#### 老年代垃圾回收器

1. Seral Old(串行GC)收集器：Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用**“标记-整理”**算法。主要使用在Client模式下的虚拟机。如果在Server模式下，那么它还有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
2. CMS(并发GC)收集器：是一种以获取最短回收停顿时间为目标的收集器，适用于集中在互联网站或者B/S系统的服务端的Java应用。CMS收集器是基于**“标记-清除”**算法实现的，整个收集过程大致分为4个步骤：
   - 初始标记：标记与根集合节点直接关联的节点。时间非常短，需要STW
   - 并发标记：遍历之前标记到的关联节点，继续向下标记所有存活节点。时间较长。
   - 重新标记：重新遍历trace并发期间修改过的引用关系对象。时间介于初始标记与并发标记之间，通常不会很长。需要STW
   - 并发清理：直接清除非存活对象，清理之后，将该线程占用的CPU切换给用户线程
3. Parallel Old（并行GC）收集器：是Parallel Scavenge收集器的老年代版本，使用多线程和**“标记-整理”**算法，可以充分利用多核CPU的计算能力，<font color="red">Java8中默认的老年代收集器</font>。

#### G1收集器

G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。
G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。在JDK1.7版本正式启用，移除了Experimental的标识，是<font color="red">JDK9以后的默认垃圾回收器</font>，取代了CMS回收器以及Parallel + Parallel old组合，被oracle官方称为“全功能的垃圾收集器”。与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-XX：+UseG1GC来启用。



### CMS垃圾回收器的优缺点？

CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，主要有三个显著缺点：cpu敏感，浮动垃圾，空间碎片

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，适用于集中在互联网站或者B/S系统的服务端的Java应用。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：

1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrenr mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快。并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

缺点：

1. CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。
2. CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full  GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。
3. CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full  GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full  GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full  GC之后，跟着来一次碎片整理过程。

### 

### Java8中默认的垃圾收集器

Java8中使用命令java -XX:+PrintCommandLineFlags -version查看GC收集器，可以看到"-XX:+UseParallelGC"参数。此参数不仅仅是采用了Parallel Scavenge(并行回收GC)，自从JDK7u4开始，就对 "-XX:+UseParallelGC" 默认的老年代收集器进行了改进，改进使得HotSpot VM在选择使用 "-XX:+UseParallelGC" 时，会默认开启 " -XX:+UseParallelOldGC "，也就是说默认的老年代收集器是 Parallel Old。综上，JDK8中默认的选择是"-XX:+UseParallelGC"，是 Parallel Scavenge + Parallel Old组合。

![image-20211107221431050](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111072214054.png)

Java9中默认采用G1垃圾收集器，取代了CMS回收器以及Parallel + Parallel old组合。

![image-20211107221227324](https://gitee.com/guohangbk/resources/raw/master/images/blog/202111072212533.png)





